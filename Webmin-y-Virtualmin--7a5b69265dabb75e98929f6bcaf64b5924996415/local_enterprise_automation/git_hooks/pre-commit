#!/bin/bash

# Git pre-commit hook para Virtualmin Enterprise
# Este hook se ejecuta antes de cada commit y realiza validaciones

set -e

# Colores para salida
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de configuración
PROJECT_ROOT="$(git rev-parse --show-toplevel)"
LOG_FILE="$PROJECT_ROOT/.git/hooks/pre-commit.log"

# Función para imprimir mensajes con colores
print_message() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Función para registrar mensajes en el log
log_message() {
    local message=$1
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$LOG_FILE"
}

# Función para verificar sintaxis de scripts Bash
check_bash_syntax() {
    log_message "Verificando sintaxis de scripts Bash"
    
    local bash_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(sh|bash)$')
    
    if [ -z "$bash_files" ]; then
        log_message "No hay archivos Bash para verificar"
        return 0
    fi
    
    local syntax_errors=0
    
    for file in $bash_files; do
        if [ -f "$file" ]; then
            log_message "Verificando sintaxis de $file"
            
            if bash -n "$file" >> "$LOG_FILE" 2>&1; then
                log_message "✓ Sintaxis correcta en $file"
            else
                log_message "✗ Error de sintaxis en $file"
                print_message $RED "Error de sintaxis en $file"
                syntax_errors=$((syntax_errors + 1))
            fi
        fi
    done
    
    if [ "$syntax_errors" -gt 0 ]; then
        print_message $RED "Se encontraron $syntax_errors errores de sintaxis en archivos Bash"
        return 1
    else
        log_message "Todos los archivos Bash tienen sintaxis correcta"
        return 0
    fi
}

# Función para verificar sintaxis de archivos Python
check_python_syntax() {
    log_message "Verificando sintaxis de archivos Python"
    
    local python_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(py)$')
    
    if [ -z "$python_files" ]; then
        log_message "No hay archivos Python para verificar"
        return 0
    fi
    
    # Verificar si python3 está disponible
    if ! command -v python3 &> /dev/null; then
        log_message "Python3 no está disponible, omitiendo verificación de sintaxis de Python"
        return 0
    fi
    
    local syntax_errors=0
    
    for file in $python_files; do
        if [ -f "$file" ]; then
            log_message "Verificando sintaxis de $file"
            
            if python3 -m py_compile "$file" >> "$LOG_FILE" 2>&1; then
                log_message "✓ Sintaxis correcta en $file"
            else
                log_message "✗ Error de sintaxis en $file"
                print_message $RED "Error de sintaxis en $file"
                syntax_errors=$((syntax_errors + 1))
            fi
        fi
    done
    
    if [ "$syntax_errors" -gt 0 ]; then
        print_message $RED "Se encontraron $syntax_errors errores de sintaxis en archivos Python"
        return 1
    else
        log_message "Todos los archivos Python tienen sintaxis correcta"
        return 0
    fi
}

# Función para verificar sintaxis de archivos YAML
check_yaml_syntax() {
    log_message "Verificando sintaxis de archivos YAML"
    
    local yaml_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(yml|yaml)$')
    
    if [ -z "$yaml_files" ]; then
        log_message "No hay archivos YAML para verificar"
        return 0
    fi
    
    # Verificar si python3 y pyyaml están disponibles
    if ! command -v python3 &> /dev/null; then
        log_message "Python3 no está disponible, omitiendo verificación de sintaxis de YAML"
        return 0
    fi
    
    if ! python3 -c "import yaml" >> "$LOG_FILE" 2>&1; then
        log_message "PyYAML no está disponible, omitiendo verificación de sintaxis de YAML"
        return 0
    fi
    
    local syntax_errors=0
    
    for file in $yaml_files; do
        if [ -f "$file" ]; then
            log_message "Verificando sintaxis de $file"
            
            if python3 -c "import yaml; yaml.safe_load(open('$file'))" >> "$LOG_FILE" 2>&1; then
                log_message "✓ Sintaxis correcta en $file"
            else
                log_message "✗ Error de sintaxis en $file"
                print_message $RED "Error de sintaxis en $file"
                syntax_errors=$((syntax_errors + 1))
            fi
        fi
    done
    
    if [ "$syntax_errors" -gt 0 ]; then
        print_message $RED "Se encontraron $syntax_errors errores de sintaxis en archivos YAML"
        return 1
    else
        log_message "Todos los archivos YAML tienen sintaxis correcta"
        return 0
    fi
}

# Función para verificar sintaxis de archivos JSON
check_json_syntax() {
    log_message "Verificando sintaxis de archivos JSON"
    
    local json_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(json)$')
    
    if [ -z "$json_files" ]; then
        log_message "No hay archivos JSON para verificar"
        return 0
    fi
    
    # Verificar si jq está disponible
    if ! command -v jq &> /dev/null; then
        log_message "jq no está disponible, omitiendo verificación de sintaxis de JSON"
        return 0
    fi
    
    local syntax_errors=0
    
    for file in $json_files; do
        if [ -f "$file" ]; then
            log_message "Verificando sintaxis de $file"
            
            if jq . "$file" > /dev/null 2>&1; then
                log_message "✓ Sintaxis correcta en $file"
            else
                log_message "✗ Error de sintaxis en $file"
                print_message $RED "Error de sintaxis en $file"
                syntax_errors=$((syntax_errors + 1))
            fi
        fi
    done
    
    if [ "$syntax_errors" -gt 0 ]; then
        print_message $RED "Se encontraron $syntax_errors errores de sintaxis en archivos JSON"
        return 1
    else
        log_message "Todos los archivos JSON tienen sintaxis correcta"
        return 0
    fi
}

# Función para verificar archivos ejecutables
check_executable_files() {
    log_message "Verificando archivos ejecutables"
    
    local executable_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(sh|bash|py)$')
    
    if [ -z "$executable_files" ]; then
        log_message "No hay archivos ejecutables para verificar"
        return 0
    fi
    
    local permission_errors=0
    
    for file in $executable_files; do
        if [ -f "$file" ]; then
            # Verificar si el archivo es ejecutable
            if [ -x "$file" ]; then
                log_message "✓ $file tiene permisos de ejecución"
            else
                log_message "✗ $file no tiene permisos de ejecución"
                print_message $YELLOW "Advertencia: $file no tiene permisos de ejecución"
                permission_errors=$((permission_errors + 1))
            fi
        fi
    done
    
    if [ "$permission_errors" -gt 0 ]; then
        print_message $YELLOW "Se encontraron $permission_errors archivos sin permisos de ejecución"
        return 0  # No bloquear el commit por esto
    else
        log_message "Todos los archivos ejecutables tienen permisos correctos"
        return 0
    fi
}

# Función para verificar presencia de secretos
check_secrets() {
    log_message "Verificando presencia de secretos en archivos"
    
    # Obtener archivos en el staging area
    local staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    
    if [ -z "$staged_files" ]; then
        log_message "No hay archivos para verificar secretos"
        return 0
    fi
    
    local secrets_found=0
    
    # Patrones de secretos a buscar
    local secret_patterns=(
        "password[[:space:]]*=[[:space:]]*['\"][^'\"]{4,}['\"]"
        "passwd[[:space:]]*=[[:space:]]*['\"][^'\"]{4,}['\"]"
        "api_key[[:space:]]*=[[:space:]]*['\"][^'\"]{10,}['\"]"
        "apikey[[:space:]]*=[[:space:]]*['\"][^'\"]{10,}['\"]"
        "secret[[:space:]]*=[[:space:]]*['\"][^'\"]{10,}['\"]"
        "token[[:space:]]*=[[:space:]]*['\"][^'\"]{10,}['\"]"
        "-----BEGIN[[:space:]]*PRIVATE[[:space:]]*KEY-----"
        "-----BEGIN[[:space:]]*RSA[[:space:]]*PRIVATE[[:space:]]*KEY-----"
        "-----BEGIN[[:space:]]*OPENSSH[[:space:]]*PRIVATE[[:space:]]*KEY-----"
        "AKIA[0-9A-Z]{16}"  # AWS Access Key ID
    )
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            # Ignorar archivos binarios
            if file "$file" | grep -q "binary"; then
                continue
            fi
            
            # Buscar patrones de secretos
            for pattern in "${secret_patterns[@]}"; do
                if grep -q -E "$pattern" "$file"; then
                    log_message "✗ Posible secreto encontrado en $file (patrón: $pattern)"
                    print_message $RED "Posible secreto encontrado en $file"
                    secrets_found=$((secrets_found + 1))
                    
                    # Mostrar línea con posible secreto
                    grep -n -E "$pattern" "$file" | head -1 >> "$LOG_FILE"
                fi
            done
        fi
    done
    
    if [ "$secrets_found" -gt 0 ]; then
        print_message $RED "Se encontraron $secrets_found posibles secretos. Por favor, elimínalos o usa variables de entorno."
        return 1
    else
        log_message "No se encontraron secretos en los archivos"
        return 0
    fi
}

# Función para ejecutar pruebas unitarias
run_unit_tests() {
    log_message "Ejecutando pruebas unitarias"
    
    # Verificar si hay directorio de pruebas
    if [ ! -d "$PROJECT_ROOT/tests" ]; then
        log_message "No hay directorio de pruebas, omitiendo ejecución de pruebas unitarias"
        return 0
    fi
    
    # Verificar si hay script de pruebas unitarias
    if [ -f "$PROJECT_ROOT/tests/run_unit_tests.sh" ]; then
        log_message "Ejecutando script de pruebas unitarias"
        
        if bash "$PROJECT_ROOT/tests/run_unit_tests.sh" >> "$LOG_FILE" 2>&1; then
            log_message "✓ Pruebas unitarias pasadas"
            return 0
        else
            log_message "✗ Pruebas unitarias fallidas"
            print_message $RED "Pruebas unitarias fallidas"
            return 1
        fi
    else
        log_message "No hay script de pruebas unitarias, omitiendo ejecución"
        return 0
    fi
}

# Función principal
main() {
    print_message $BLUE "Ejecutando validaciones pre-commit..."
    log_message "Iniciando validaciones pre-commit"
    
    # Crear archivo de log
    echo "=== Validaciones pre-commit - $(date) ===" > "$LOG_FILE"
    
    local validation_errors=0
    
    # Verificar sintaxis de archivos Bash
    if ! check_bash_syntax; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Verificar sintaxis de archivos Python
    if ! check_python_syntax; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Verificar sintaxis de archivos YAML
    if ! check_yaml_syntax; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Verificar sintaxis de archivos JSON
    if ! check_json_syntax; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Verificar archivos ejecutables
    check_executable_files
    
    # Verificar presencia de secretos
    if ! check_secrets; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Ejecutar pruebas unitarias
    if ! run_unit_tests; then
        validation_errors=$((validation_errors + 1))
    fi
    
    # Verificar si hay errores de validación
    if [ "$validation_errors" -gt 0 ]; then
        print_message $RED "Se encontraron $validation_errors errores de validación"
        print_message $RED "Commit abortado. Por favor, corrija los errores e intente nuevamente."
        print_message $BLUE "Para omitir estas validaciones, use: git commit --no-verify"
        exit 1
    else
        print_message $GREEN "Todas las validaciones pasaron exitosamente"
        log_message "Validaciones pre-commit completadas exitosamente"
        exit 0
    fi
}

# Ejecutar función principal
main "$@"