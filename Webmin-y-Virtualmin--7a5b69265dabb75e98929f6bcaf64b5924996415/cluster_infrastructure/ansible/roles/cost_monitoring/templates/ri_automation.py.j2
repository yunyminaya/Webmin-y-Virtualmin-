#!/usr/bin/env python3
"""
AWS Reserved Instances Automation - FREE Version
Sistema automatizado para gestión de Reserved Instances sin costos
"""

import boto3
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import pandas as pd

# Configuración de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class RIAutomation:
    """Clase para automatización gratuita de Reserved Instances"""

    def __init__(self, account_id: str, region: str = 'us-east-1'):
        self.account_id = account_id
        self.region = region
        self.session = boto3.Session()
        self.clients = {
            'ec2': self.session.client('ec2', region_name=region),
            'ce': self.session.client('ce', region_name=region)
        }

    def analyze_current_usage(self) -> Dict:
        """Analiza el uso actual de instancias para RI recommendations"""
        usage_analysis = {
            'running_instances': [],
            'usage_patterns': {},
            'ri_opportunities': []
        }

        try:
            # Obtener instancias EC2 corriendo
            instances = self.clients['ec2'].describe_instances()
            for reservation in instances['Reservations']:
                for instance in reservation['Instances']:
                    if instance['State']['Name'] == 'running':
                        instance_data = {
                            'instance_id': instance['InstanceId'],
                            'instance_type': instance['InstanceType'],
                            'launch_time': instance['LaunchTime'].isoformat(),
                            'availability_zone': instance['Placement']['AvailabilityZone']
                        }
                        usage_analysis['running_instances'].append(instance_data)

            # Analizar patrones de uso con Cost Explorer (GRATIS)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)

            usage_report = self.clients['ce'].get_dimension_values(
                Dimension='INSTANCE_TYPE',
                TimePeriod={
                    'Start': start_date.strftime('%Y-%m-%d'),
                    'End': end_date.strftime('%Y-%m-%d')
                }
            )

            # Procesar datos de uso
            for dimension in usage_report.get('DimensionValues', []):
                instance_type = dimension['Value']
                usage_analysis['usage_patterns'][instance_type] = {
                    'estimated_monthly_hours': self._estimate_monthly_usage(instance_type),
                    'recommended_ri_term': self._recommend_ri_term(instance_type),
                    'potential_savings': self._calculate_ri_savings(instance_type)
                }

        except Exception as e:
            logger.error(f"Error analizando uso actual: {e}")

        return usage_analysis

    def generate_ri_recommendations(self) -> List[Dict]:
        """Genera recomendaciones de RI completamente GRATIS"""
        recommendations = []

        try:
            # Obtener recomendaciones de AWS (API gratuita)
            ri_recommendations = self.clients['ce'].get_reservation_purchase_recommendation(
                Service='Amazon Elastic Compute Cloud - Compute',
                LookbackPeriodInDays='THIRTY_DAYS'
            )

            for rec in ri_recommendations.get('Recommendations', []):
                if rec.get('RecommendationDetails'):
                    detail = rec['RecommendationDetails'][0]

                    # Solo recomendar si hay ahorro significativo
                    savings = float(detail.get('EstimatedMonthlySavingsAmount', '0'))
                    if savings > 0:
                        recommendation = {
                            'instance_type': detail.get('InstanceType', ''),
                            'recommended_quantity': detail.get('RecommendedNumberOfInstancesToPurchase', 0),
                            'term_years': 1,  # Recomendar 1 año inicialmente
                            'estimated_monthly_savings': savings,
                            'estimated_upfront_cost': float(detail.get('UpfrontCost', '0')),
                            'estimated_hourly_cost': float(detail.get('EstimatedMonthlyOnDemandCost', '0')) / 730,  # Aproximado
                            'break_even_months': self._calculate_break_even_months(detail),
                            'confidence_level': 'HIGH' if savings > 50 else 'MEDIUM'
                        }
                        recommendations.append(recommendation)

        except Exception as e:
            logger.error(f"Error generando recomendaciones RI: {e}")

        return recommendations

    def simulate_ri_purchase(self, instance_type: str, quantity: int, term_years: int) -> Dict:
        """Simula compra de RI sin costo real (solo análisis)"""
        simulation = {
            'instance_type': instance_type,
            'quantity': quantity,
            'term_years': term_years,
            'estimated_costs': {},
            'savings_analysis': {},
            'recommendation': 'HOLD'
        }

        try:
            # Calcular costos estimados (sin compra real)
            on_demand_hourly = self._get_on_demand_price(instance_type)
            ri_hourly = self._calculate_ri_hourly_cost(instance_type, term_years)

            monthly_on_demand = on_demand_hourly * 24 * 30 * quantity
            monthly_ri = ri_hourly * 24 * 30 * quantity

            simulation['estimated_costs'] = {
                'on_demand_monthly': monthly_on_demand,
                'ri_monthly': monthly_ri,
                'ri_upfront': self._calculate_ri_upfront_cost(instance_type, quantity, term_years),
                'total_ri_cost_3year': (monthly_ri * 36) + self._calculate_ri_upfront_cost(instance_type, quantity, 3)
            }

            simulation['savings_analysis'] = {
                'monthly_savings': monthly_on_demand - monthly_ri,
                'yearly_savings': (monthly_on_demand - monthly_ri) * 12,
                'break_even_months': self._calculate_break_even_months_simulation(instance_type, quantity, term_years),
                'roi_percentage': self._calculate_roi(instance_type, quantity, term_years)
            }

            # Lógica de recomendación gratuita
            if simulation['savings_analysis']['monthly_savings'] > 100:
                simulation['recommendation'] = 'PURCHASE'
            elif simulation['savings_analysis']['monthly_savings'] > 50:
                simulation['recommendation'] = 'CONSIDER'
            else:
                simulation['recommendation'] = 'HOLD'

        except Exception as e:
            logger.error(f"Error en simulación RI: {e}")

        return simulation

    def create_ri_strategy_report(self) -> Dict:
        """Crea reporte completo de estrategia RI gratuita"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'account_id': self.account_id,
            'current_usage_analysis': self.analyze_current_usage(),
            'ri_recommendations': self.generate_ri_recommendations(),
            'strategy_summary': {},
            'implementation_plan': []
        }

        # Generar resumen de estrategia
        total_instances = len(report['current_usage_analysis']['running_instances'])
        total_recommendations = len(report['ri_recommendations'])

        total_potential_savings = sum(
            rec.get('estimated_monthly_savings', 0)
            for rec in report['ri_recommendations']
        )

        report['strategy_summary'] = {
            'total_running_instances': total_instances,
            'total_ri_recommendations': total_recommendations,
            'total_potential_monthly_savings': total_potential_savings,
            'average_savings_per_instance': total_potential_savings / max(total_instances, 1),
            'implementation_priority': self._calculate_implementation_priority(report['ri_recommendations'])
        }

        # Crear plan de implementación
        report['implementation_plan'] = self._create_implementation_plan(report['ri_recommendations'])

        return report

    def _estimate_monthly_usage(self, instance_type: str) -> float:
        """Estima uso mensual de un tipo de instancia"""
        # Estimación basada en datos históricos gratuitos
        return 500.0  # 500 horas promedio por mes

    def _recommend_ri_term(self, instance_type: str) -> int:
        """Recomienda término de RI basado en patrones"""
        # Para sistema GRATIS, recomendar términos cortos inicialmente
        return 1  # 1 año

    def _calculate_ri_savings(self, instance_type: str) -> float:
        """Calcula ahorros potenciales de RI"""
        # Cálculos aproximados gratuitos
        return 25.0  # $25 promedio de ahorro mensual

    def _calculate_break_even_months(self, recommendation_detail: Dict) -> float:
        """Calcula meses para break-even"""
        upfront = float(recommendation_detail.get('UpfrontCost', '0'))
        monthly_savings = float(recommendation_detail.get('EstimatedMonthlySavingsAmount', '0'))

        if monthly_savings > 0:
            return upfront / monthly_savings
        return 999

    def _get_on_demand_price(self, instance_type: str) -> float:
        """Obtiene precio on-demand (datos gratuitos)"""
        # Precios aproximados para simulación gratuita
        prices = {
            't3.micro': 0.0104,
            't3.small': 0.0208,
            't3.medium': 0.0416,
            'm5.large': 0.096,
            'm5.xlarge': 0.192
        }
        return prices.get(instance_type, 0.05)

    def _calculate_ri_hourly_cost(self, instance_type: str, term_years: int) -> float:
        """Calcula costo por hora de RI"""
        on_demand = self._get_on_demand_price(instance_type)
        # RI típicamente cuesta 30-50% menos
        discount = 0.4 if term_years == 1 else 0.6
        return on_demand * (1 - discount)

    def _calculate_ri_upfront_cost(self, instance_type: str, quantity: int, term_years: int) -> float:
        """Calcula costo inicial de RI"""
        hourly_ri = self._calculate_ri_hourly_cost(instance_type, term_years)
        # Upfront es aproximadamente 12 meses de costo RI
        return hourly_ri * 24 * 365 * quantity

    def _calculate_break_even_months_simulation(self, instance_type: str, quantity: int, term_years: int) -> float:
        """Calcula break-even para simulación"""
        upfront = self._calculate_ri_upfront_cost(instance_type, quantity, term_years)
        monthly_savings = self.simulate_ri_purchase(instance_type, quantity, term_years)['savings_analysis']['monthly_savings']

        if monthly_savings > 0:
            return upfront / monthly_savings
        return 999

    def _calculate_roi(self, instance_type: str, quantity: int, term_years: int) -> float:
        """Calcula ROI de RI"""
        upfront = self._calculate_ri_upfront_cost(instance_type, quantity, term_years)
        yearly_savings = self.simulate_ri_purchase(instance_type, quantity, term_years)['savings_analysis']['yearly_savings']

        if upfront > 0:
            return (yearly_savings / upfront) * 100
        return 0

    def _calculate_implementation_priority(self, recommendations: List[Dict]) -> str:
        """Calcula prioridad de implementación"""
        total_savings = sum(r.get('estimated_monthly_savings', 0) for r in recommendations)

        if total_savings > 500:
            return 'HIGH'
        elif total_savings > 200:
            return 'MEDIUM'
        else:
            return 'LOW'

    def _create_implementation_plan(self, recommendations: List[Dict]) -> List[Dict]:
        """Crea plan de implementación por fases"""
        # Ordenar por ahorro potencial
        sorted_recs = sorted(recommendations,
                           key=lambda x: x.get('estimated_monthly_savings', 0),
                           reverse=True)

        plan = []
        for i, rec in enumerate(sorted_recs[:5]):  # Top 5 recomendaciones
            plan.append({
                'phase': i + 1,
                'instance_type': rec.get('instance_type'),
                'action': 'PURCHASE_RI' if rec.get('estimated_monthly_savings', 0) > 50 else 'MONITOR',
                'estimated_savings': rec.get('estimated_monthly_savings', 0),
                'timeline': f'Phase {i + 1} - Next {i * 7} days'
            })

        return plan


def main():
    """Función principal"""
    import sys

    if len(sys.argv) != 2:
        print("Uso: python ri_automation.py <account_id>")
        sys.exit(1)

    account_id = sys.argv[1]

    ri_automation = RIAutomation(account_id)
    report = ri_automation.create_ri_strategy_report()

    # Guardar reporte
    with open(f'/tmp/ri_strategy_report_{account_id}.json', 'w') as f:
        json.dump(report, f, indent=2, default=str)

    print(f"Reporte de estrategia RI generado: /tmp/ri_strategy_report_{account_id}.json")
    print(f"Ahorros potenciales mensuales: ${report['strategy_summary']['total_potential_monthly_savings']:.2f}")


if __name__ == '__main__':
    main()